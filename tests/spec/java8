# SIGMA
'<>=+-_*/\\%(){}[],.;:#!?^@&|"\'~ \t\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'

#----------------------------------------------------------------------------------------------------------------------#
# CDFA                                                                                                                 #
#----------------------------------------------------------------------------------------------------------------------#

start
    '{' -> ^LBRACE
    '}' -> ^RBRACE
    '(' -> ^LPAREN
    ')' -> ^RPAREN
    '[' -> ^LARRI
    ']' -> ^RARRI

    ',' -> ^COMMA
    ';' -> ^SEMI
    ':' -> colon

    '@' -> ^AT

    # OPERATORS
    '=' -> eq
    '<' -> lt
    '>' -> gt
    '!' -> not
    '+' -> plus
    '-' -> minus
    '*' -> star
    '%' -> pct
    '/' -> slash
    '~' -> ^COMP
    '&' -> and
    '^' -> ^OR_BE
    '|' -> or
    '?' -> ^QST
    '.' -> dot

    # LITERALS
    '"' -> string
    '\'' -> char
    '0' -> zero
    'true' | 'false' | 'null' -> ^LIT
    '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' -> num

    # KEYWORDS
    'abstract' -> ^ABSTRACT
    'assert' -> ^ASSERT
    'boolean' -> ^PRIM
    'break' -> ^BREAK
    'byte' -> ^PRIM
    'case' -> ^CASE
    'catch' -> ^CATCH
    'char' -> ^PRIM
    'class' -> ^CLASS
    'const' -> ^CONST
    'continue' -> ^CONTINUE
    'default' -> ^DEFAULT
    'do' -> ^DO
    'double' -> ^PRIM
    'else' -> ^ELSE
    'enum' -> ^ENUM
    'extends' -> ^EXTENDS
    'final' -> ^FINAL
    'finally' -> ^FINALLY
    'float' -> ^PRIM
    'for' -> ^FOR
    'goto' -> ^GOTO
    'if' -> ^IF
    'implements' -> ^IMPLEMENTS
    'import' -> ^IMPORT
    'instanceof' -> ^CMP_REL
    'int' -> ^PRIM
    'interface' -> ^INTERFACE
    'long' -> ^PRIM
    'native' -> ^NATIVE
    'new' -> ^NEW
    'package' -> ^PACKAGE
    'private' -> ^VISIBILITY
    'protected' -> ^VISIBILITY
    'public' -> ^VISIBILITY
    'return' -> ^RETURN
    'short' -> ^PRIM
    'static' -> ^STATIC
    'strictfp' -> ^STRICTFP
    'super' -> ^SUPER
    'switch' -> ^SWITCH
    'synchronized' -> ^SYNCHRONIZED
    'this' -> ^THIS
    'throw' -> ^THROW
    'throws' -> ^THROWS
    'transient' -> ^TRANSIENT
    'try' -> ^TRY
    'void' -> ^VOID
    'volatile' -> ^VOLATILE
    'while' -> ^WHILE

    # MISC
    ' ' | '\t' | '\n' -> ws
    '#' -> fail
    _ -> id;

#
# OPERATORS
#

eq      ^ASSN
    '=' -> ^CMP_EQ;

not     ^NOT
    '=' -> ^CMP_EQ;

lt      ^LT
    '=' -> ^CMP_REL;

gt      ^GT
    '=' -> ^CMP_REL;

plus    ^PLUS
    '+' -> ^INC
    '=' -> ^ASSN;

minus   ^MINUS
    '>' -> ^ARROW
    '-' -> ^DEC
    '=' -> ^ASSN;

star    ^OP_MULT
    '=' -> ^ASSN;

pct     ^OP_MULT
    '=' -> ^ASSN;

slash   ^OP_MULT
    '/' -> lcom
    '*' -> bcom
    '=' -> ^ASSN;

and     ^AND
    '&' -> ^AND_L;

or      ^OR_BI
    '|' -> ^OR_L;

dot     ^DOT
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' -> float
    '..' -> ^TRIDOT;

#
# LITERALS
#

string
    '"' -> ^LIT
    '\\"' -> string
    _ -> string;

char    # ignoring length
    '\'' -> ^LIT
    _ -> char;

zero    ^LIT
    'x' | 'X' -> hex
    'b' | 'B' -> bin
    '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' -> oct
    'e' | 'E' -> floatexp
    'f' | 'd' | 'F' | 'D' -> ^LIT;

num     ^LIT
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '_' -> num
    '.' -> float
    'e' | 'E' -> floatexp
    'f' | 'd' | 'F' | 'D' -> ^LIT;

bin  ^LIT
    '0' | '1' | '_' -> bin;

hex     ^LIT
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C'
        | 'D' | 'E' | 'F' | '_' -> hex;

oct   ^LIT
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '_' -> oct;

float   ^LIT
    '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '_' -> float
    'e' | 'E' -> floatexp
    'f' | 'd' | 'F' | 'D' -> ^LIT;

floatexp
    '-' | '+' -> floatexp
    '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' -> float;

#
# MISC
#

colon   ^COLON
    ':' -> ^M_REF;

ws      ^_
    ' ' | '\t' | '\n' -> ws;

lcom ^_
    '\n' -> fail
    _ -> lcom;

bcom
    '*/' -> bcomm # TODO get rid of this after introducing comments
    _ -> bcom;

bcomm ^_; # TODO get rid of this after introducing comments

id | ABSTRACT | ASSERT | PRIM | BREAK | PRIM | CASE | CATCH | ENUM | CLASS | CONST | CONTINUE | DEFAULT | DO | ELSE
    | EXTENDS | FINAL | FINALLY | FOR | GOTO | IF | IMPLEMENTS | IMPORT | CMP_REL | INTERFACE | NATIVE | NEW | PACKAGE
    | VISIBILITY | RETURN | STATIC | STRICTFP | SUPER | SWITCH | SYNCHRONIZED | THIS | THROW | THROWS | TRANSIENT | TRY
    | VOID | VOLATILE | WHILE   ^ID
    'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's'
        | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K'
        | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '$' | '_' | '0'
        | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' -> id;

#----------------------------------------------------------------------------------------------------------------------#
# GRAMMAR                                                                                                              #
#----------------------------------------------------------------------------------------------------------------------#

cmp_unit
    -> package_decl_opt ImportDeclarationsOpt TypeDeclarationsOpt;

package_decl_opt
    -> annotations_opt PACKAGE id_chain SEMI
    ->;

ImportDeclarationsOpt
    -> ImportDeclarations
    ->;
ImportDeclarations
    -> ImportDeclaration ImportDeclarations
    -> ImportDeclaration;
ImportDeclaration
    -> IMPORT typename SEMI
    -> IMPORT typename DOT STAR SEMI
    -> IMPORT STATIC typename DOT ID SEMI
    -> IMPORT STATIC typename DOT STAR SEMI;

TypeDeclarationsOpt
    -> TypeDeclarations
    ->;
TypeDeclarations
    -> TypeDeclaration TypeDeclarations
    -> TypeDeclaration;
TypeDeclaration
    -> class_dec
    -> enum_dec
    -> interface_dec
    -> annotation_dec
    -> SEMI;

#
# CLASS
#

class_dec
    -> modifiers_opt CLASS ID type_parameters_opt superclass_opt superinterfaces_opt class_body;

superclass_opt
    -> superclass
    ->;
superclass
    -> EXTENDS class_type;

superinterfaces_opt
    -> superinterfaces
    ->;
superinterfaces
    -> IMPLEMENTS class_types;

class_body_opt
    -> class_body
    ->;
class_body
    -> LBRACE class_body_decs_opt RBRACE;
class_body_decs_opt
    -> class_body_decs
    ->;
class_body_decs
    -> class_body_dec class_body_decs
    -> class_body_dec;
class_body_dec
    -> class_member_dec
    -> instance_init
    -> static_init
    -> constructor_dec;

class_member_dec
    -> field_dec
    -> method_dec
    -> class_dec
    -> interface_dec
    -> SEMI;

instance_init
    -> block;

static_init
    -> STATIC block;

constructor_dec
    -> modifiers_opt constructor_declarator throws_opt constructor_body;
constructor_body
    -> LBRACE explicit_constructor_invocation_opt block_statements_opt RBRACE;
constructor_declarator
    -> type_parameters_opt ID LPAREN formal_parameter_list_opt RPAREN;

explicit_constructor_invocation_opt
    -> explicit_constructor_invocation
    ->;
explicit_constructor_invocation
    -> type_arguments_opt THIS LPAREN argument_list_opt RPAREN SEMI
    -> type_arguments_opt SUPER LPAREN argument_list_opt RPAREN SEMI
    -> expr_name DOT type_arguments_opt SUPER LPAREN argument_list_opt RPAREN SEMI
    -> primary DOT type_arguments_opt SUPER LPAREN argument_list_opt RPAREN SEMI;

argument_list_opt
    -> argument_list
    ->;
argument_list
    -> expr COMMA expr
    -> expr;

field_dec
    -> modifiers_opt type variable_declarator_list SEMI;

method_dec
    -> modifiers_opt method_header method_body;
method_header
    -> result method_declarator throws_opt
    -> type_parameters annotations_opt result method_declarator throws_opt;
method_declarator
    -> ID LPAREN formal_parameter_list_opt RPAREN array_dims_opt;
method_body
    -> block
    -> SEMI;

formal_parameter_list_opt
    -> formal_parameter_list
    ->;
formal_parameter_list
    -> receiver_parameter
    -> formal_parameters COMMA last_formal_parameter
    -> last_formal_parameter;
formal_parameters
    -> formal_parameter COMMA formal_parameters
    -> receiver_parameter COMMA formal_parameters
    -> formal_parameter
    -> receiver_parameter;
formal_parameter
    -> modifiers_opt unann_type variable_declarator_id;
receiver_parameter
    -> annotations_opt unann_type ID DOT THIS
    -> annotations_opt unann_type THIS;
last_formal_parameter
    -> modifiers_opt unann_type annotations_opt TRIDOT variable_declarator_id
    -> formal_parameter;

throws_opt
    -> throws
    ->;
throws
    -> THROWS exception_type_list;

exception_type_list
    -> exception_type COMMA exception_type_list
    -> exception_type;
exception_type
    -> class_type
    -> type_variable;

result
    -> unann_type
    -> VOID;

#
# ENUM
#

enum_dec
    -> modifiers_opt ENUM ID superinterfaces_opt enum_body;

enum_body
    -> LBRACE enum_const_list_opt comma_opt enum_body_declarations_opt RBRACE;

enum_const_list_opt
    -> enum_constant_list
    ->;
enum_const_list
    -> enum_constant COMMA enum_constant_list
    -> enum_constant;
enum_const
    -> annotations_opt ID enum_const_arg_list_opt class_body_opt;
enum_const_arg_list_opt
    -> LPAREN argument_list_opt RPAREN
    ->;

enum_body_declarations_opt
    -> SEMI class_body_decs_opt
    ->;

#
# INTERFACE
#

interface_dec
    -> modifiers_opt INTERFACE ID type_parameters_opt extends_interfaces_opt interface_body;

extends_interfaces_opt
    -> EXTENDS class_types
    ->;

interface_body
    -> LBRACE interface_member_decs_opt RBRACE;

interface_member_decs_opt
    -> interface_member_decs
    ->;
interface_member_decs
    -> interface_member_dec interface_member_decs
    -> interface_member_dec;
interface_member_dec
    -> const_dec
    -> method_dec
    -> class_dec
    -> interface_dec
    -> SEMI;

const_dec
    -> const_modifers_opt unann_type variable_declarator_list;

#
# ANNOTATION
#

annotation_dec
    -> modifiers_opt AT INTERFACE ID annotation_body;

annotation_body
    -> LBRACE annotation_member_decs_opt RBRACE;

annotation_member_decs_opt
    -> annotation_member_decs
    ->;
annotation_member_decs
    -> annotation_member_dec annotation_member_decs
    -> annotation_member_dec;
annotation_member_dec
    -> annotation_element_dec
    -> const_dec
    -> class_dec
    -> interface_dec
    -> SEMI;

annotation_element_dec
    -> modifiers_opt unann_type ID LPAREN RPAREN array_dims_opt default_value_opt SEMI;

default_value_opt
    -> default_value
    ->;
default_value
    -> DEFAULT ElementValue;

#
# TYPE
#

type_parameters_opt
    -> type_parameters
    ->;
type_parameters
    -> LT type_parameter_list GT;
type_parameter_list
    -> type_parameter COMMA type_parameter_list
    -> type_parameter;
type_parameter
    -> annotations_opt ID type_bound_opt;

type_bound_opt
    -> type_bound
    ->;
type_bound
    -> EXTENDS type_variable
    -> EXTENDS class_type AND additional_bounds_opt;
additional_bounds_opt
    -> additional_bounds
    ->;
additional_bounds
    -> class_type AND additional_bounds
    -> class_type;

type_arguments_opt
    -> LT type_arguments GT
    ->;
type_arguments
    -> type_argument COMMA type_arguments
    -> type_argument;
type_argument
    -> type
    -> wildcard;

type
    -> non_array_type array_dims_opt;

typename
    -> typename DOT ID
    -> ID;

non_array_type
    -> class_type
    -> primitive_type;

class_types
    -> class_type COMMA class_types
    -> class_type;
class_type
    -> class_type DOT class_type_internal
    -> class_type_internal;
class_type_internal
    -> type_variable type_arguments_opt;

class_type_to_instantiate
    -> annotated_ids type_arguments
    -> annotated_ids LT GT
    -> annotated_ids;

class_literal
    -> typename unann_array_dims_opt DOT CLASS
    -> PRIM unann_array_dims_opt DOT CLASS
    -> VOID DOT CLASS;

type_variable
    -> annotations_opt ID;

primitive_type
    -> annotations_opt PRIM;

array_dims_opt
    -> array_dims
    ->;
array_dims
    -> array_dim array_dims
    -> array_dim;
array_dim
    -> annotations_opt LARRI RARRI;

unann_type
    -> unann_non_array_type array_dims_opt;

unann_non_array_type
    -> unann_class_type
    -> ID
    -> PRIM;

unann_class_type
    -> unann_class_type DOT annotations_opt unann_class_type_internal
    -> unann_class_type_internal;
unann_class_type_internal
    -> ID type_arguments_opt;

unann_array_dims_opt
    -> unann_array_dims
    ->;
unann_array_dims
    -> unann_array_dim unann_array_dims
    -> unann_array_dim;
unann_array_dim
    -> LARRI RARRI;

wildcard
    -> annotations_opt QST wildcard_bounds_opt;
wildcard_bounds_opt
    -> wildcard_bounds
    ->;
wildcard_bounds
    -> EXTENDS type
    -> SUPER type;

#
# MISC
#

ElementValuePairsOpt
    -> ElementValuePairs
    ->;
ElementValuePairs
    -> ElementValuePair COMMA ElementValuePairs
    -> ElementValuePair;
ElementValuePair
    -> ID ASSN ElementValue;
ElementValue
    -> conditional_expr
    -> ElementValueArrayInitializer
    -> annotation;
ElementValueArrayInitializer
    -> LBRACE ElementValuesOpt comma_opt RBRACE;
ElementValuesOpt
    -> ElementValues
    ->;
ElementValues
    -> ElementValue COMMA ElementValues
    -> ElementValue;

annotations_opt
    -> annotations
    ->;
annotations
    -> annotation annotations
    -> annotation;
annotation
    -> AT typename LPAREN ElementValuePairsOpt RPAREN
    -> AT typename LPAREN ElementValue RPAREN
    -> AT typename;

annotated_ids
    -> annotations_opt ID DOT annotated_ids
    -> annotations_opt ID;

id_chain
    -> ID DOT id_chain
    -> ID;

comma_opt
    -> COMMA
    ->;

semi_opt
    -> SEMI
    ->;

variable_declarator_list
    -> variable_declarator COMMA variable_declarator_list
    -> variable_declarator;
variable_declarator
    -> variable_declarator_id variable_initializer_opt;
variable_declarator_id
    -> ID array_dims_opt;

variable_initializers_opt
    -> variable_initializers
    ->;
variable_initializers
    -> variable_initializer COMMA variable_initializer
    -> variable_initializer;
variable_initializer_opt
    -> ASSN variable_initializer # should really just be equals
    ->;
variable_initializer
    -> expr
    -> array_initializer;

array_initializer
    -> LBRACE variable_initializers_opt comma_opt RBRACE;

block
    -> LBRACE block_statements_opt RBRACE;

#
# STATEMENTS
#

block_statements_opt
    -> block_statements
    ->;
block_statements
    -> block_statement block_statements
    -> block_statement;
block_statement
    -> lvar_dec_statement
    -> class_dec
    -> statement;

lvar_dec_statement
    -> lvar_dec SEMI;
lvar_dec
    -> modifiers_opt unann_type variable_declarator_list;

statement
    -> statement_without_trailing_substatement
    -> labeled_statement
    -> if_then_statement
    -> if_then_else_statement
    -> while_statement
    -> for_statement;

statement_nsi
    -> statement_without_trailing_substatement
    -> labeled_statement_nsi
    -> if_then_else_statement_nsi
    -> while_statement_nsi
    -> for_statement_nsi;

statement_without_trailing_substatement
    -> block
    -> SEMI
    -> statement_expression SEMI
    -> assert_statement
    -> switch_statement
    -> do_statement
    -> break_statement
    -> continue_statement
    -> return_statement
    -> synchronized_statement
    -> throw_statement
    -> try_statement;

statement_expression_list
    -> statement_expression COMMA statement_expression_list
    -> statement_expression;
statement_expression
    -> assignment
    -> INC unary_expr
    -> DEC unary_expr
    -> postfix_expr INC
    -> postfix_expr DEC
    -> method_invocation
    -> class_icreation_expr;

assignment
    -> lhs ASSN expr;

assert_statement
    -> ASSERT expr SEMI
    -> ASSERT expr COLON expr SEMI;

switch_statement
    -> SWITCH LPAREN expr RPAREN switch_block;

switch_block
    -> LBRACE switch_bsgs_opt switch_labels_opt RBRACE;

switch_bsgs_opt
    -> switch_bsgs
    ->;
switch_bsgs
    -> switch_bsg switch_bsgs
    -> switch_bsg;
switch_bsg
    -> switch_labels block_statements;

switch_labels_opt
    -> switch_labels
    ->;
switch_labels
    -> switch_label switch_labels
    -> switch_label;
switch_label
    -> CASE expr COLON
    -> CASE ID COLON
    -> DEFAULT COLON;

do_statement
    -> DO statement WHILE LPAREN expr RPAREN SEMI;

break_statement
    -> BREAK SEMI
    -> BREAK ID SEMI;

continue_statement
    -> CONTINUE SEMI
    -> CONTINUE ID SEMI;

return_statement
    -> RETURN SEMI
    -> RETURN expr SEMI;

synchronized_statement
    -> SYNCHRONIZED LPAREN expr RPAREN block;

throw_statement
    -> THROW expr SEMI;

try_statement
    -> TRY block catches
    -> TRY block catches_opt finally
    -> try_with_resources_statement;

try_with_resources_statement
    -> TRY resource_specification block catches_opt finally_opt;
resources_specification
    -> LPAREN resources semi_opt RPAREN;
resources
    -> resource SEMI resources
    -> resource;
resource
    -> modifiers_opt unnan_type variable_declarator_id ASSN expr;

finally_opt
    -> finally
    ->;
finally
    -> FINALLY block;

catches_opt
    -> catches
    ->;
catches
    -> catch_clause catches
    -> catch_clause;
catch_clause
    -> CATCH LPAREN catch_formal_parameter RPAREN block;
catch_formal_parameter
    -> modifiers_opt catch_type variable_declarator_id;
catch_type
    -> unann_class_type catch_type_internal;
catch_type_internal
    -> OR_BI class_type catch_type_internal
    ->;

labeled_statement
    -> ID COLON statement;

labeled_statement_nsi
    -> ID COLON statement_nsi;

if_then_statement
    -> IF LPAREN expr RPAREN statement;

if_then_else_statement
    -> IF LPAREN expr RPAREN statement_nsi ELSE statement;

if_then_else_statement_nsi
    -> IF LPAREN expr RPAREN statement_nsi ELSE statement_nsi;

while_statement
    -> WHILE LPAREN expr RPAREN statement;

while_statement_nsi
    -> WHILE LPAREN expr RPAREN statement_nsi;

for_statement
    -> basic_for_statement statement
    -> enhanced_for_statement statement;

for_statement_nsi
    -> basic_for_statement statement_nsi
    -> enhanced_for_statement statement_nsi;

basic_for_statement
    -> FOR LPAREN for_init_opt SEMI expr_opt SEMI for_update_opt RPAREN;

for_init_opt
    -> for_init
    ->;
for_init
    -> lvar_dec
    -> statement_expression_list;

for_update_opt
    -> for_update
    ->;
for_update
    -> statement_expression_list;

enhanced_for_statement
    -> FOR LPAREN modifiers_opt unann_type variable_declarator_id COLON expr RPAREN;

#
# EXPRESSIONS
#

expr_opt
    -> expr
    ->;
expr
    -> lambda_expr
    -> conditional_expr
    -> lhs ASSN expr;

lhs
    -> expr_name
    -> field_access
    -> array_access;

lambda_expr
    -> lambda_params ARROW lambda_body;

lambda_body
    -> expr
    -> block;

conditional_expr
    -> conditional_or_expr
    -> conditional_or_expr QST expr COLON conditional_expr
    -> conditional_or_expr QST expr COLON lambda_expr;

conditional_or_expr
    -> conditional_and_expr
    -> conditional_or_expr OR_L conditional_and_expr;

conditional_and_expr
    -> inclusive_or_expr
    -> conditional_and_expr AND_L inclusive_or_expr;

inclusive_or_expr
    -> exclusive_or_expr
    -> inclusive_or_expr OR_BI exclusive_or_expr;

exclusive_or_expr
    -> and_expr
    -> exclusive_or_expr OR_BE and_expr;

and_expr
    -> equality_expr
    -> and_expr AND equality_expr;

equality_expr
    -> relational_expr
    -> equality_expr CMP_EQ relational_expr;

relational_expr
    -> shift_expr
    -> relational_expr CMP_REL shift_expr
    -> relational_expr LT shift_expr
    -> relational_expr GT shift_expr;

shift_expr
    -> additive_expr
    -> shift_expr LT LT additive_expr
    -> shift_expr GT GT additive_expr
    -> shift_expr GT GT GT additive_expr;

additive_expr
    -> multiplicative_expr
    -> additive_expr PLUS multiplicative_expr
    -> additive_expr MINUS multiplicative_expr;

multiplicative_expr
    -> unary_expr
    -> multiplicative_expr OP_MULT unary_expr;

unary_expr
    -> INC unary_expr
    -> DEC unary_expr
    -> PLUS unary_expr
    -> MINUS unary_expr
    -> unary_expr_not_plus_minus;

unary_expr_not_plus_minus
    -> COMP unary_expr
    -> NOT unary_expr
    -> postfix_expr
    -> cast_expr;

postfix_expr
    -> primary
    -> expr_name
    -> postfix_expr INC
    -> postfix_expr DEC;

cast_expr
    -> LPAREN PRIM RPAREN unary_expr
    -> LPAREN type additional_bounds_opt RPAREN unary_expr_not_plus_minus
    -> LPAREN type additional_bounds_opt RPAREN lambda_expr;

expr_name
    -> ID
    -> expr_name DOT ID;

primary
    -> primary_no_new_array
    -> array_creation_expr;

primary_no_new_array
    -> LIT
    -> class_literal
    -> THIS
    -> typename DOT THIS
    -> LPAREN expr RPAREN
    -> class_icreation_expr
    -> field_access
    -> array_access
    -> method_invocation
    -> method_reference;

class_icreation_expr
    -> unqualified_class_icreation_expr
    -> expr_name DOT unqualified_class_icreation_expr
    -> primary DOT unqualified_class_icreation_expr;

unqualified_class_icreation_expr
    -> NEW type_arguments_opt class_type_to_instantiate LPAREN arguments_opt RPAREN class_body_opt;

field_access
    -> primary DOT ID
    -> SUPER DOT ID
    -> typename DOT super DOT ID;

array_access
    -> expr_name LARRI expr RARRI
    -> primary_no_new_array LARRI expr RARRI;

method_invocation
    -> ID LPAREN arguments_opt RPAREN
    -> typename DOT type_arguments_opt ID LPAREN arguments_opt RPAREN
    -> expr_name DOT type_arguments_opt ID LPAREN arguments_opt RPAREN
    -> primary DOT type_arguments_opt ID LPAREN arguments_opt RPAREN
    -> SUPER DOT type_arguments_opt ID LPAREN arguments_opt RPAREN
    -> typename DOT SUPER DOT type_arguments_opt ID LPAREN arguments_opt RPAREN;

arguments_opt
    -> arguments
    ->;
arguments
    -> expr COMMA arguments
    -> expr;

method_reference
    -> expr_name M_REF type_arguments_opt ID
    -> type M_REF type_arguments_opt ID
    -> primary M_REF type_arguments_opt ID
    -> SUPER M_REF type_arguments_opt ID
    -> typename M_REF type_arguments_opt ID
    -> class_type M_REF type_arguments_opt NEW
    -> array_type M_REF NEW;

array_creation_expr
    -> NEW PRIM dim_exprs array_dims_opt
    -> NEW class_type dim_exprs array_dims_opt
    -> NEW PRIM array_dims array_initializer
    -> NEW class_type array_dims array_initializer;

dim_exprs
    -> dim_expr dim_exprs
    -> dim_expr;
dim_expr
    -> annotations_opt LARRI expr RARRI;

#
# MODIFIERS
#

modifiers_opt
    -> modifiers
    ->;
modifiers
    -> modifier modifiers
    -> modifier;
modifier
    -> annotation
    -> VISIBILITY
    -> ABSTRACT
    -> STATIC
    -> FINAL
    -> SYNCHRONIZED
    -> NATIVE
    -> STRICTFP
    -> TRANSIENT
    -> VOLATILE;